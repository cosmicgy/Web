<!-- 
html은 정보와 구조화, css 는 styling  
1. 선택자 selector : 스타일을 적용하고자 하는  html 요소 
    - 프로퍼티 : 값;

2.  <link rel="stylesheet" href="css/style.css"> 링크 방식이 아닌 embedding 이나 inline style 을 사용할 수 있으나 복잡해짐 링크 스타일 추천 

3. reset css 사용하기 : 모든 웹 브라우저는 디폴트 스타일이 있다. reset css는 디폴트 스타일을 하나의 스타일로 통일시켜주는 역할을 함
  - eric meyer's reset/ normalize.css 
  - reset.css 파일을 따로 만든 뒤 실제 css파일에 import 하여 적용

4. 복수개의 셀렉터를 연속으로 지정 가능하며, 쉽표로 구분 h1, p{color : red;}

5. 셀렉터 
  - 전체 선택 * head 요소도 포함 
  - 태그셀렉터 태그명 
  - id셀렉터 #id 어트리뷰트 값/ 중복 불가
  - 클랙스 셀렉터 .class 어트리뷰트 값 / 중복 가능

  1) 어트리뷰트 셀렉터 
      - 셀렉터[어트리뷰트] 지정된 어트리뷰트를 갖는 모든 요소를 선택
      - 셀렉터[어트리뷰트="값"] 지정된 어트리뷰트를 가지며 지정된 값과 어트리뷰트의 값이 일치하는 모든 요소를 선택한다. 
      - 샐랙터[어트리뷰트~="값"] 지정된 어트리뷰트의 값이 지정된 값을 단어로 포함하는 요소를 선택 
      - 셀렉터[어트리뷰트|="값"] 지정된 어트리뷰트의 값과 일치하거나 지정 어트리뷰트 값 뒤 연이은 하이픈(“값-“)으로 시작하는 요소를 선택한다.
      - 셀렉터[어트리뷰트^="값"] 지정된 어트리뷰트 값으로 시작하는 요소를 선택
      - 셀렉터[어트리뷰트$="값"] 지정된 어트리뷰트 값으로 끝나는 요소를 선택
      - 셀렉터[어트리뷰트*="값"] 지정된 어트리뷰트 값을 포함하는 요소를 선택

  2) 복합 셀렉터 (combinator)
      - 자신의 1레벨 상위에 속하는 요소를 부모요소, 1레벨 하위에 속하는 요소를 자손 요소(자식 요소)라 한다. 
      - 자신보다 n 레벨 하위에 속하는 요소는 후손요소 (하위요소) 라고 한다. 
      - 후손 셀렉터는 셀렉터 A의 모든 후손(하위) 요소 중 셀렉터 B와 일치하는 요소를 선택한다. 
      셀렉터 A 셀렉터 B

  3) 자식 셀렉터 (Child combinator)
      - 자손 셀렉터는 셀렉터 A 의 모든 자식 요소 중 셀렉터 B와 일치하는 요소를 선택한다. 
      셀렉터A > 셀렉터B

  4) 형제(동위) 셀렉터 (sibling combinator) : 형제 셀렉터는 형제관계에서 뒤에 위치하는 요소를 선택할 때 사용 
      - 인접 형제 셀렉터 (adjacent sibling combinator) : 셀렉터 a의 형제 요소 중 셀렉터 a 바로 뒤에 위치하는 셀렉터 b요소를 선택한다. a와b사이에 다른 요소가 존재하면 선택되지 않음 
      셀렉터a + 셀렉터b
      - 일반 형제 셀렉터 : 셀렉터 a의 형제 요소 중 셀렉터 a 뒤에 위치하는 셀렉터 b 요소를 모두 선택 
      셀렉터a ~ 셀렉터b

  5) 가상클래스 셀렉터  : 요소의 특정 상태에 따라 스타일을 정의할 때 사용 / 원래 클래스가 존재하지 않지만 가상 클래스를 임의로 지정하여 선택하는 방법 / 마침표대신 콜론 : 을 사용/ css 표준에 의해 미리 정의된 이름이 있기 때문에 임의의 이름 사용할 수 없음 
    - 마우스가 올라와 있을 때
    - 링크를 방문했을 때와 아직 방문하지 않았을 때 
    - 포커스가 들어와 있을 때 
    5-1) 링크 셀렉터, 동적 셀렉터 
      - :link 셀렉터가 방문하지 않은 링크일 때 
      - :visited 셀렉터가 방문한 링크일 때 
      - :hover 셀렉터에 마우스가 올라와 있을 때 
      - :active 셀렉터가 클릭된 상태일 때 
      - :focus 셀렉터에 포커스가 들어와 있을 때 
    5-2) ui 요소 상태 셀렉터 
      - :checked 셀렉터가 체크 상태일 때 
      - :enabled 셀렉터가 사용 가능한 상태일 때 
      - :disabled 셀렉터가 사용 불가능한 상태일 때 
    5-3) 구조 가상 클래스 셀렉터 
      - :first-child 셀렉터에 해당하는 모든 요소 중 첫번째 자식인 요소를 선택한다 
      - :last-child 셀렉터에 해당하는 모든 요소 중 마지막 자식인 요소를 선택한다
      - :nth-child(n) 셀렉터에 해당하는 모든 요소 중 앞에서 n번째 자식인 요소를 선택 
      - :nth-last-child(n) 셀렉터에 해당하는 모든 요소 중 뒤에서 n번째 자식인 요소 선택 
        (n은 0부터 시작하는 정수)
      - :first-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 요소를 선택 
      - :last-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 마지막에 등장하는 요소를 선택
      - :nth-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 앞에서 n번째에 등장하는 요소를 선택
      - :nth-last-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 뒤에서 n번째에 등장하는 요소를 선택
    5-4) 부정 셀렉터 
      - :not(셀렉터) 셀렉터에 해당하지 않는 모든 요소를 선택 
    5-5) 정합성 체크 셀렉터 
      - :valid(셀렉터) 정합성 검증이 성공한  input 요소 또는 form 요소를 선택한다 
      - :invalid(셀렉터) 정합성 검증이 실패한 input 요소 또는 form 요소를 선택 

  6) 가상 요소 셀렉터 : 가상 요소는 요소의 특정 부분에 스타일을 적용하기 위해 사용/ 가상 요소에는 두개의 콜론 :: 을 사용한다/ css표준에 의해 정의된 이름이 있기 때문에 임의의 이름 사용 불가 
    - 요소 콘텐츠의 첫 글자 또는 첫줄
    - 요소 콘텐츠의 앞 또는 뒤 
    - ::first-letter 콘텐츠의 첫글자
    - ::first-line 콘텐츠의 첫줄/ 블록 요소에만 적용가능
    - ::after 콘텐츠의 뒤에 위치하는 공간을 선택/ 일반적으로 content 프로퍼티와 함께 사용
    - ::before 콘텐츠의 앞에 위치하는 공간/ 일반적으로 content 프로퍼티와 함께 사용
    - ::selection 드래그한 콘텐츠를 선택/ iOS Safari 등 일부 브라우저에서 동작 않는다.

6. css 프로퍼티 값의 단위  : 키워드, 크기단위, 색상 표현 단위 등 특정 단위를 갖는 값을 지정한다 
  - 키워드 : 각 프로퍼티에 따라 사용할 수 있는 키워드가 존재함. display 프로퍼티의 값으로 사용할 수 있는 키워드는 block, inline, inline-block, none 이 있다. 
  - 크기 단위 : cm, mm, inch 등의 단위도 존재하나 css에서는 px, em, %를 사용 
    px 절대값,  em과 %는 상대값 / 대부분 브라우저의 폰트 사이즈 기본값은 16px 1em 100% 이다. 프로퍼티 값이 0인 경우 단위를 생략할 수 있다. 
  - px : 픽셀(화소). 1680*1050 의 해상도란 가로에 1 680개 세로에 1050개의 픽셀을 가진다는 의미 / 디바이스 해상도에 다라 상대적인 크기를 갖는다/ 디바이스별로 픽셀의 크기는 제각각이기 때문에 픽셀을 기준으로 하는 단위는 명확하지 않으나 1px를 1/96인치의 절대단위로 인식함 
  - % : 백분률 단위의 상대 단위, 요소에 지정된 사이즈(상속된 사이즈나 디폴트 사이즈)에 상대적인 사이즈 설정 
  - em : 배수 단위로 상대 단위, 요소에 지정된 사이즈(상속된 사이즈나 디폴트 사이즈)에 상대적인 사이즈 설정, 1em은 요소에 지정된 사이즈와 같고 2em은 요소에 지정된 사이즈의 2배 / 폰트 사이즈 설정이나 콘텐츠를 포함하는 컨테이너의 크기 설정에 사용하면 상대적인 설정이 가능하여 편리함 
    중첩된 자식 요소에 em을 지정하면 모든 자식 요소의 사이즈에 영향을 미치기 때문에 주의하여 사용 / 상대단위인 em의 기준이 상속의 영향으로 바뀔 수 있음 
  - rem : em은 상속의 영향으로 바뀔 수 있다. 상황에 따라 1.2em은 각기 다른 값을 갖게 된다. rem 은 최상위 요소(html) 의 사이즈를 기준으로 삼는다. rem의 r은 root를 의미한다. 
    폰트사이즈뿐아니라 콘텐츠의 크기에 따라 가변적으로 대응해야하는 wrapper 요소 container 등에 적합 / reset css 를 사용하여 사전에 html요소의 font-size지정이 필요. 미 지정시에는 16px가 적용된다. 
    .container {
    width: 70rem; /* 70rem ⇒ 14px * 70 = 980px */
  - viewport 단위(vh, vw, vmin, vmax) 반응형 웹디자인은 화면의 크기에 동적으로 대응하기 위해 %단위를 자주 사용, 하지만 em 처럼 상속에 의해 부모 요소에 상대적 영향을 받음. viewport 단위는 상대적인 단위로 viewport를 기준으로 한 상대적 사이즈를 의미함. 
      -vw : viewport 너비의 1/100
      -vh : viewport 높이의 1/100
      -vmin : viewport 너비 또는 높이 중 작은 쪽의 1/100
      -vmax : viewport 노비 또는 높이 중 큰 쪽의 1/100

      .item {
      width: 50vw;
      height: 100vh;
      text-align: center;
      line-height: 100vh;
      font-size: 4rem;
      color: white;
      }

  7. 박스모델 (*어려움... 특히 box-sizing프로퍼티..)
      - content : 요소의 텍스트나 이미지 등 실제 내용이 위치하는 영억/ width, height 프로퍼티를 갖는다 
      - padding : 테두리 안쪽에 위치하는 요소의 내부 여백 영역이댜ㅏ. padding 프로퍼티 값은 패딩 영역의 두께를 의미. 기본색은 투명/ 요소에 적용된 배경 컬러, 이미지는 패딩 영역까지 적용됨
      - border : 테두리 영역/ border 프로퍼티 값을 테두리의 두께 
      - margin : 테두리 바깥에 위치하는 외부 여백 영역/ margin 프로퍼티 값은 마진 영역의 두께를 의미/ 기본적으로 투명하며 배경색 지정 불가 

      7-1) width/height 프로퍼티 : 요소의 너비와 높이를 지정/ 콘텐츠 영역을 대상으로 한다 -> box-sizing 프로퍼티에 기본값인 content-box가 적용되었기 때문. box-sizing 프로퍼티에 border-box를 적용하면 콘텐츠 영역, padding,border 가 포함된 영역을 width/height 프로퍼티의 대상으로 지정할 수 있다. 
        -먼저 width와 height로 지정한 콘텐츠 영역보다 실제 콘텐츠가 크면 콘텐츠 영역을 넘치게 된다는 것에 유의 
        -기본적으로 width와 height는 콘텐츠 영역을 대상으로 요소의 너비와 높이를 지정하기 때문에 전체 크기의 계산이 가능하다. 
        -width와 height 프로퍼티의 초기값은 auto로 브라우저가 상황에 따라 적당한  width와 height값을 계산할 것을 의미/ block요소의 경우 width는 부모 요소의 100%, height 는 콘텐츠의 높이 (+약간의 여분) 가 지정됨
        -명시적으로 둘을 지정하기 위해서는 px, %등의 크기 단위를 사용 
      * width와 height 프로퍼티를 비롯한 모든 박스모델 관련 프로퍼티(margin, padding, border, box-sizing 등)는 상속되지 않는다.
      7-2) margin/ padding 프로퍼티 : content의 4개 방향(top, right, left, bottom) 에 대해 지정 가능 
        - -top, -right, -bottom, -left 4방향의 프로퍼티를 각각 지정하지 않고 margin, padding 1개의 프로퍼티만으로 4방향의 프로퍼티를 한번에 지정할 수 있다.
        ex) 4개의 값을 지정할 때 margin: 25px 50px 75px 100px;
            margin-top: 25px;
            margin-right: 50px;
            margin-bottom: 75px;
            margin-left: 100px;
            3개의 값을 지정할 때 margin: 25px 50px 75px;
            margin-top: 25px;
            margin-right: 50px; margin-left: 50px;
            margin-bottom: 75px
            2개의 값을 지정할 때 margin: 25px 50px;
            margin-top: 25px; margin-bottom: 25px;
            margin-right: 50px; margin-left: 50px;
            1개의 값을 지정할 때 margin: 25px;
            margin-top: 25px; margin-right: 25px; margin-bottom: 25px; margin-left: 25px;
        - margin 프로퍼티에 auto 키워드를 설정하면 해당 요소를 브라우저 중앙에 위치 시킬 수 있음  margin: 0 auto;
        - 요소 너비가 브라우저 너비보다 크면 가로 스크롤바가 만들어진다. 이 문제를 해결하기 위해서 max-width 프로퍼티를 사용할 수 있다.
        max-width 프로퍼티를 사용하면 브라우저 너비가 요소의 너비보다 좁아질 때 자동으로 요소의 너비가 줄어든다. max-width: 600px;
        ex) max-width 프로퍼티는 요소 너비의 최대값을, min-width 프로퍼티는 요소 너비의 최소값을 지정한다. max-width: 300px;의 경우 브라우저의 너비가 300px보다 작아지면 요소 너비는 브라우저의 너비에 따라서 작아진다. 
        min-width: 300px; 의 경우 브라우저의 너비가 300px보다 작아져도 요소 너비는 지정 너비(300px)을 유지한다.
      7-3) border 프로퍼티 : border-width, border-style, border-color를 한번에 설정하기 위한 shorthand 프로퍼티
        - border-style : 테두리 선의 스타일 / 프로퍼티 값의 갯수에 따라 4개 방향(top, right, left, bottom)에 대하여 지정이 가능
        - border-width : 테두리의 두께/ 4개 방향(top, right, left, bottom)에 대하여 지정 가능/ 반드시 border-style와 함께 사용해야 지정 가능함  border-style: solid
        - border-color :  테두리의 색상/ 프로퍼티 값의 갯수에 따라 4개 방향(top, right, left, bottom)에 대하여 지정이 가능/ 반드시 border-style와 함께 사용 border-style: solid
        - border-radius : 테두리 모서리를 둥글게 표현/ 길이를 나타내는 단위(px, em 등)와 %를 사용/ 각각의 모서리에 개별적으로 지정할 수도 있고 4개의 모서리를 short-hand로 한번에 지정할 수도 있다.
      7-4) box-sizing 프로퍼티 : width, height 프로퍼티의 대상 영역을 변경할 수 있음 / 기본값은 content-box
      box-sizing 프로퍼티의 값을 border-box로 지정하면 마진을 제외한 박스 모델 전체를 width, height 프로퍼티의 대상 영역으로 지정할 수 있어서 CSS Layout을 직관적으로 사용할 수 있음.
        - content-box	: width, height 프로퍼티 값은 content 영역을 의미한다. (기본값)
        - border-box : width, height 프로퍼티 값은 content 영역, padding, border가 포함된 값을 의미함 
      box-sizing 프로퍼티는 상속되지 않음. box-sizing 프로퍼티를 사용하도록 초기화하려면 아래와 같이 정의한다.
      
      html {
        box-sizing: border-box;
      }
      *, *:before, *:after {
        box-sizing: inherit;
      }

  8. display, visibility, opacity 프로퍼티
      8-1) display 프로퍼티 : layout 정의에 자주 사용되는 중요한 프로퍼티
      - block	: block 특성을 가지는 요소(block 레벨 요소)로 지정
      - inline : inline 특성을 가지는 요소(inline 레벨 요소)로 지정
      - inline-block: inline-block 특성을 가지는 요소(inline-block 레벨 요소)로 지정
      - none: 해당 요소를 화면에 표시하지 않는다 (공간조차 사라진다)
      모든 HTML 요소는 아무런 CSS를 적용하지 않아도 기본적으로 브라우저에 표현되는 디폴트 표시값을 가짐/ HTML 요소는 block 또는 inline 특성을 가짐/ display 프로퍼티는 상속되지 않음

      - block 레벨 요소 : 항상 새로운 라인에서 시작/ 화면 크기 전체의 가로폭을 차지함 (width: 100%)/ width, height, margin, padding 프로퍼티 지정이 가능/ block 레벨 요소 내에 inline 레벨 요소를 포함할 수 있음. 
      ex) div/ h1~h6/ p/ ol/ul/ li/hr/ table/ form 
      - inline 레벨 요소 : 새로운 라인에서 시작하지 않으며 문장의 중간에 들어갈 수 있음./ 줄을 바꾸지 않고 다른 요소와 함께 한 행에 위치함./ content의 너비만큼 가로폭을 차지함./ width, height, margin-top, margin-bottom 프로퍼티를 지정할 수 없음 /상, 하 여백은 line-height로 지정함./ inline 레벨 요소 뒤에 공백(엔터, 스페이스 등)이 있는 경우, 정의하지 않은 space(4px)가 자동 지정됨/ inline 레벨 요소 내에 block 레벨 요소를 포함할 수 없음/ inline 레벨 요소는 일반적으로 block 레벨 요소에 포함되어 사용됨
      ex) span/ a/ strong/ img/ br/ input/ select/ textarea/ button 
      - inline-block 레벨 요소 : block과 inline 레벨 요소의 특징을 모두 가짐/ inline 레벨 요소와 같이 한 줄에 표현되면서 width, height, margin 프로퍼티를 모두 지정할 수 있음. 
      기본적으로 inline 레벨 요소와 흡사하게 줄을 바꾸지 않고 다른 요소와 함께 한 행에 위치시킬 수 있다.
      block 레벨 요소처럼 width, height, margin, padding 프로퍼티를 모두 정의할 수 있음/ 상, 하 여백을 margin과 line-height 두가지 프로퍼티 모두를 통해 제어할 수 있다.
      content의 너비만큼 가로폭을 차지한다./ inline-block 레벨 요소 뒤에 공백(엔터, 스페이스 등)이 있는 경우 정의하지 않은 space(4px)가 자동 지정된다. 
      
      8-2) visibility 프로퍼티 :요소를 보이게 할 것인지 보이지 않게 할 것인지를 정의/ 요소의 랜더링 여부 결정 
      - visible :	해당 요소를 보이게 한다 (기본값)
      - hidden: 해당 요소를 보이지 않게 한다. display: none;은 해당 요소의 공간까지 사라지게 하지만 visibility: hidden;은 해당 요소의 공간은 사라지지 않고 남아있게 된다.
      - collapse:	table 요소에 사용하며 행이나 열을 보이지 않게 한다.
      - none:	table 요소의 row나 column을 보이지 않게 한다. IE, 파이어폭스에서만 동작하며 크롬에서는 hidden과 동일하게 동작한다.

      8-3) opacity 프로퍼티 : 요소의 투명도/ 0.0 ~ 1.0의 값, 0.0은 투명, 1.0은 불투명 opacity: 1.0;

    9. 백그라운드 : 해당 요소의 배경으로 이미지 또는 색상을 정의
      9-1) background-image 프로퍼티 : 요소에 배경 이미지를 지정
      9-2) background-repeat 프로퍼티 : 배경 이미지의 반복을 지정/ 수직, 수평 또는 수직과 수평 모두의 반복 지정 가능 /  background-repeat 프로퍼티의 기본값은 repeat/ x축으로만 배경 이미지를 반복할 경우, background-repeat 프로퍼티값에 repeat-x, y축으로만 배경 이미지를 반복할 경우, repeat-y를 설정/ 반복 출력을 멈추고 싶은 경우, background-repeat 프로퍼티값에 no-repeat를 설정/ background-image에 복수개의 이미지를 설정할 경우, 먼저 설정된 이미지가 전면에 출력
      9-3) background-size 프로퍼티 : 배경 이미지의 사이즈 지정/ 프로퍼티값은 px, %, cover, contain 등 사용/ 배경이미지의 width, height를 모두 설정가능/ 첫번째 값은 width, 두번째 값은 height를 의미/ 하나의 값만을 지정한 경우, 지정한 값은 width를 의미하게 되며 height는 auto로 지정
        - px값 지정 : 배경이미지 크기가 지정된 px값 그대로 설정
        - %값 지정 : 배경이미지 크기가 지정된 %값에 비례하여 설정/ 화면을 줄이거나 늘리면 배경이미지의 크기도 따라서 변경되어 찌그러지는 현상이 나타남/ background-size: 100% 100%; /width, height의 프로퍼티값은 공백으로 구분
        - cover 지정 : 배경이미지의 크기 비율을 유지한 상태에서 부모 요소의 width, height 중 큰값에 배경이미지를 맞춘다/ 이미지의 일부가 보이지 않을 수 있다. background-size: cover;
        - contain 지정 : 배경이미지의 크기 비율을 유지한 상태에서 부모 요소의 영역에 배경이미지가 보이지 않는 부분없이 전체가 들어갈 수 있도록 이미지 스케일을 조정   background-size: contain;
      9-4) background-attachment 프로퍼티 : 화면이 스크롤되더라도 배경이미지는 스크롤되지 않고 고정되어 있게 하려면 background-attachment 프로퍼티에 fixed 키워드를 지정
      9-5) background-position 프로퍼티 : background-image는 좌상단부터 이미지를 출력하지만 background-position 프로퍼티를 사용하면 이미지의 좌표(xpos, ypos)를 지정 할 수 있다/ 기본값은 background-position: 0% 0%;로 배경이미지는 우측 상단에 위치하게 된다.
      9-6) background-color 프로퍼티 : 배경 색상/ transparent 키워드를 지정
      background Shorthand : background-color, background-image, background-repeat, background-position를 한번에 정의
      background: color || image || repeat || attachment || position 
      
    10. 폰트와 텍스트 : 폰트의 크기, 폰트의 지정, 폰트의 스타일, 텍스트 정렬 등을 정의
      10-1) font-size 프로퍼티 : 텍스트의 크기
      10-2) font-family 프로퍼티 : 퓨터에 해당 폰트가 설치되어 있지 않으면 적용되지 않음/ 여러개 동시 지정 가능/ 첫번째 지정한 폰트가 클라이언트 컴퓨터에 설치되어 있지 않으면 다음에 지정된 폰트를 적용함/ 따라서 마지막에 지정하는 폰트는 대부분의 OS에 기본적으로 설치되어 있는 generic-family 폰트(Serif, Sans-serif, Mono space)를 지정하는 것이 일반적임/ 폰트명은 따옴표로 감싸주며 폰트명이 한단어인 경우는 따옴표 사용하지 않아도됨 
      10-3) font-style / font-weight 프로퍼티 : 이탤릭체지정/ 폰트 굵기 지정 
      font: 하고 shorthand로 사용 가능 

      10-4) line-height 프로퍼티 : 텍스트의 높이 지정/ 수직 정렬에도 응용되어 사용 16px가 디폴트 
      10-5) letter-spacing 프로퍼티 : 글자 사이의 간격을 지정
      10-6) text-align 프로퍼티 : 텍스트의 수평 정렬
        - h1 { text-align: center; }
        - h3 { text-align: right; }
        - p.left  { text-align: left; }
        - p.justify  { text-align: justify; }
        - a  { text-align: center; }
         -> a 요소에 대한 중앙 정렬은 적용되지 않는다. a 요소는 inline 요소이기 때문/ inline 요소는 width 프로퍼티가 없으므로 중앙 개념이 존재하지 않는다. a 요소에 display: block;을 지정한다면 중앙 정렬이 가능함
      10-7) text-decoration 프로퍼티 : 링크 underline을 제거할 수 있음/ 텍스트에 underline, overline, line-through를 추가할 수도 있음 
        - text-decoration: none;
        - text-decoration: overline;
      10-8) white-space 프로퍼티 : white space는 공백(space), 들여쓰기(tab), 줄바꿈(line break)을 의미/ html은 기본적으로 연속된 공백(space), 들여쓰기(tab)는 1번만 실행되며 줄바꿈(line break)은 무시된다. 또한 텍스트는 부모의 가로 영역을 벗어나지 않고 자동 줄바꿈(wrap)된다. white-space 프로퍼티는 이러한 기본 동작을 제어하기 위한 프로퍼티이다. white-space: normal;
        - normal : line break	무시/	space, tab 1번만 반영/	wrapping(자동줄바꿈) O
        - nowrap:	line break 무시/	space, tab 1번만 반영/	wrapping(자동줄바꿈) X
        - pre:	line break 반영/	space, tab 그대로 반영/	wrapping(자동줄바꿈) X
        - pre-wrap:	line break 반영/	space, tab 그대로 반영/	wrapping(자동줄바꿈) O
        - pre-line:	line break 반영/	space, tab 1번만 반영/	wrapping(자동줄바꿈) O
      10-9) text-overflow 프로퍼티 : 부모 영역을 벗어난 wrapping(자동줄바꿈)이 되지 않은 텍스트의 처리 방법을 정의함/ 이 프로퍼티를 사용하기 위해서는 아래의 조건이 필요함 text-overflow: ellipsis;
        - width 프로퍼티가 지정되어 있어야 한다. 이를 위해 필요할 경우 block 레벨 요소로 변경하여야 한다.
        - 자동 줄바꿈을 방지하려면 white-space 프로퍼티를 nowrap으로 설정한다.
        - overflow 프로퍼티에 반드시 “visible” 이외의 값이 지정되어 있어야 한다.
        clip : 영역을 벗어난 텍스트를 표시하지 않는다. (기본값)	 
        ellipsis : 영역을 벗어난 텍스트를 잘라내어 보이지 않게 하고 말줄임표(…)를 표시한다.	 
        <!– :	<string> 지정한 임의의 문자열 출력 
      10-10) word-wrap 프로퍼티 : 한 단어의 길이가 길어서 부모 영역을 벗어난 텍스트의 처리 방법을 정의/ link 등을 표기할 때(e.g. https://poiemaweb.com/css3-font-text) 그 길이가 매우 길어지는데 이 프로퍼티를 사용하지 않으면 부모 영역을 넘어가게 된다.
      word-wrap: break-word;
      10-11) word-break 프로퍼티 : word-wrap 프로퍼티는 단어를 어느 정도는 고려하지만 (.,- 등을 고려한다) word-break: break-all;는 단어를 고려하지 않고 부모 영역에 맞추어 강제로 표현된다.
      word-break: break-all;

    11. 요소의 위치 정의
      - position 프로퍼티 :  요소의 위치를 정의/ top, bottom, left, right 프로퍼티와 함께 사용하여 위치를 지정함/ 
      11-1)  static (기본위치) :  position 프로퍼티의 기본값으로 position 프로퍼티를 지정하지 않았을 때와 같다./ 기본적인 요소의 배치 순서에 따라 위에서 아래로, 왼쪽에서 오른쪽으로 순서에 따라 배치/ 자식 요소로서 존재할 때는 부모 요소의 위치를 기준으로 배치/ 좌표 프로퍼티(top, bottom, left, right)를 같이 사용할 수 없으며 사용할 경우에는 무시됨  position: static;.
      11-2) relative (상대위치) : 기본 위치(static으로 지정되었을 때의 위치)를 기준으로 좌표 프로퍼티(top, bottom, left, right)를 사용하여 위치를 이동/ static을 선언한 요소와 relative를 선언한 요소의 차이점은 좌표 프로퍼티의 동작 여부뿐이며 그외는 동일하게 동작함 
      11-3) absolute (절대위치) : 부모 요소 또는 가장 가까이 있는 조상 요소(static 제외)를 기준으로 좌표 프로퍼티(top, bottom, left, right)만큼 이동/ relative, absolute, fixed 프로퍼티가 선언되어 있는 부모 또는 조상 요소를 기준으로 위치가 결정/ 만일 부모 또는 조상 요소가 static인 경우, document body를 기준으로 하여 좌표 프로퍼티대로 위치 -> 따라서 부모 요소를 배치의 기준으로 삼기 위해서는 부모 요소에 relative를 정의/ absolute 선언 시, block 레벨 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정해야함 

      * relative 프로퍼티와 absolute 프로퍼티의 차이점
      relative 프로퍼티는 기본 위치(static으로 지정되었을 때의 위치)를 기준으로 좌표 프로퍼티(top, bottom, left, right)을 사용하여 위치를 이동시킴 -> 무조건 부모를 기준으로 위치
      absolute 프로퍼티는 부모에 static 이외의 position 프로퍼티가 지정되어 있을 경우에만 부모를 기준으로 위치하게 된다. 만일 부모, 조상이 모두 static 프로퍼티인 경우, document body를 기준으로 위치하게 됨 -> absolute 프로퍼티 요소는 부모 요소의 영역을 벗어나 자유롭게 어디든지 위치할 수 있음. 

      11-4) fixed (고정위치) : 부모 요소와 관계없이 브라우저의 viewport를 기준으로 좌표프로퍼티(top, bottom, left, right)을 사용하여 위치를 이동/ 스크롤이 되더라도 화면에서 사라지지 않고 항상 같은 곳에 위치함/ fixed 프로퍼티 선언 시, block 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정해야함/ 
      11-5) z-index 프로퍼티 : 큰 숫자값을 지정할수록 화면 전면에 출력됨/ positon 프로퍼티가 static 이외인 요소에만 적용됨
      11-6) overflow 프로퍼티 : 자식 요소가 부모 요소의 영역를 벗어났을 때 처리 방법을 정의
      - visible	: 영역을 벗어난 부분을 표시한다. (기본값) .visible { overflow: visible; }
      - hidden :	영역을 벗어난 부분을 잘라내어 보이지 않게 한다. .hidden  { overflow: hidden; }
      - scroll	: 영역을 벗어난 부분이 없어도 스크롤 표시한다.(현재 대부분 브라우저는 auto과 동일하게 작동한다) .scroll  { overflow: scroll; }
      - auto :	영역을 벗어난 부분이 있을때만 스크롤 표시한다.  .auto    { overflow: auto; }
    
    12. 요소 정렬
      float 프로퍼티 : 주로 레이아웃을 구성할 때 블록 레벨 요소를 가로 정렬하기 위해 사용되는 중요한 기법/ 이미지와 텍스트가 있을 때, 이미지 주위를 텍스트로 감싸기 위해 만들어진 것
      요소가 기본 레이아웃 흐름에서 벗어나 요소의 모서리가 페이지의 왼쪽이나 오른쪽에 이동하게 함/  float 프로퍼티를 사용할 때 요소의 위치를 고정시키는 position 프로퍼티의 absolute를 사용하면 안된다.
      - none	요소를 떠 있게 하지 않는다. (기본값)
      - right	요소를 오른쪽으로 이동시킨다
      - left	요소를 왼쪽으로 이동시킨다.
      12-1) 정렬 : float 프로퍼티를 사용하지 않은 블록 요소들은 수직으로 정렬된다. float:left; 프로퍼티를 사용하면 왼쪽부터 가로 정렬되고, float:right; 프로퍼티를 사용하면 오른쪽부터 가로 정렬된다.
      float 프로퍼티는 좌측, 우측 가로 정렬만 할 수 있음/ 중앙 가로 정렬은 margin 프로퍼티를 사용해야 함. margin: 0 auto;
      12-2) width : width 프로퍼티의 기본값은 100%/ width 프로퍼티값을 지정하지 않은 block 요소는 부모 요소의 가로폭을 가득 채우게됨 
      width 프로퍼티를 선언하지 않은 block 레벨 요소에 float 프로퍼티가 선언되면 width가 inline 요소와 같이 content에 맞게 최소화되고 다음 요소 위에 떠 있게 됨 
      - overflow: hidden; 프로퍼티는 자식 요소가 부모 요소의 영역보다 클 경우 넘치는 부분을 안보이게 해주는 역할을 하는데 여기서는 float 프로퍼티가 없어서 제대로 표현되지 못하는 요소를 제대로 출력해준다.
      모든 요소에 float 프로퍼티를 선언하면 overflow: hidden 프로퍼티는 선언하지 않아도 되지만 너비가 최소화된다.
      - float 프로퍼티가 선언된 자식 요소를 포함하는 부모 요소의 높이가 정상적으로 반영되지 않을때 
      float 프로퍼티가 선언된 두개의 자식 요소를 포함하는 부모 요소의 높이가 정상적인 값을 가지지 못하는 문제가 발생/ float 요소는 일반적인 흐름 상에 존재하지 않기 때문에 float 요소의 높이를 알 수 없기 때문인데 이 문제는 부모 요소 이후에 위치하는 요소의 정렬에 문제를 발생시킴
      ->(해결방법1) float 프로퍼티가 선언된 자식 요소의 부모 요소(.container)에 overflow: hidden 프로퍼티를 선언하는 것
      .container {
       ...
       overflow: hidden;
      }
      ->(해결방법2) 부모 요소(.container)에 float 프로퍼티를 선언하는 방법/ 부모 요소의 너비는 float된 두개의 자식요소의 콘텐츠를 표현할 수 있는 만큼만으로 작게 줄어들게 됨. 권장하지않음.
      ->(해결방법3) container 영역이 끝나기 직전 빈 요소를 만들고 clear:both를 설정하는 방법도 있음/ 하지만 의미 없는 빈 요소를 사용하여야 하기 때문에 권장하지않음 
      ->(해결방법4)  ::after 가상 요소 선택자를 이용
      ->(해결방법5) display: inline-block;을 선언하는 것/ display: inline-block;을 선언하여 텍스트와 같이 배치되도록 했으나 두 요소 사이에 정의하지 않은 공백(4px)이 자동 지정되어 부모 요소의 width를 초과하여 가로 정렬이 되지 않음 이를 해결하기 위해 부모 요소에 font-size: 0;을 선언하여 두 요소 사이에 정의하지 않은 공백을 제거한다 

    13. 스타일의 상속과 적용 우선 순위
      13-1) 상속 :상위(부모 조상) 요소에 적용된 프로퍼티를 하위(자식 자손) 요소가 물려 받는 것/ 모든 프로퍼티가 상속되는 것은아님
      -> 상속되지 않는 경우에는 inherit 키워드를 사용하여 명시적으로 상속받게 할 수 있음  color: inherit; 이런식으로 
      13-2) 캐스캐이딩 :  CSS 적용 우선순위 (중요도, 명시도, 선언순서)
      - 중요도 : CSS가 어디에 선언 되었는지에 따라서 우선순위가 달라짐
        head 요소 내의 style 요소
        head 요소 내의 style 요소 내의 @import 문
        <link> 로 연결된 CSS 파일
        <link> 로 연결된 CSS 파일 내의 @import 문
        브라우저 디폴트 스타일시트

      - 명시도 : 대상을 명확하게 특정할수록 명시도가 높아지고 우선순위가 높아짐
        !important > 인라인 스타일 > 아이디 선택자 > 클래스/어트리뷰트/가상 선택자 > 태그 선택자 > 전체 선택자 > 상위 요소에 의해 상속된 속성
        ex)   p { color: red !important; }

      - 선언순서 : 선언된 순서에 따라 우선 순위가 적용됨/ 나중에 선언된 스타일이 우선 적용됨! 
    
    14. 벤더 프리픽스 
      * {
       -webkit-user-select: none;  /* Chrome all / Safari all */
       -moz-user-select: none;     /* Firefox all */
       -ms-user-select: none;      /* IE 10+ */
        user-select: none;          /* Likely future */
      }
      Prefix Free 사이트에서 라이브러리를 다운로드하고 include 하기만 하면 이 후에는 벤더 프리픽스없이 모든 CSS를 사용할 수 있음 <script src="prefixfree.min.js"></script>
    
    15. 그림자 :텍스트나 요소에 그림자(Shadow) 효과를 부여하기 위한 프로퍼티
      15-1) text-shadow : 텍스트에 그림자 효과 부여/ 선택자 { text-shadow: Horizontal-offset Vertical-offset Blur-Radius Shadow-Color; }
      Horizontal-offset	그림자를 텍스트의 오른쪽으로 지정값만큼 이동시킨다 (단위px)
      Vertical-offset	그림자를 텍스트의 아래로 지정값만큼 이동시킨다 (단위px)
      Blur-Radius	그림자의 흐림정도를 지정/ 지정값만큼 그림자가 커지고 흐려진다.(양수)

      15-2) box-shadow : 요소에 그림자 효과를 부여하는 프로퍼티/ 선택자 { box-shadow: Inset Horizontal-offset Vertical-offset Blur-Radius Spread Shadow-Color; }
      Inset	키워드를 지정하면 그림자가 요소 안쪽에 위치한다. (단위inset)
      Horizontal-offset	그림자를 텍스트의 오른쪽으로 지정값만큼 이동시킨다 (단위px)
      Vertical-offset	그림자를 텍스트의 아래로 지정값만큼 이동시킨다 (단위px)	 
      Blur-Radius	그림자의 흐림정도를 지정한다. 지정값만큼 그림자가 커지고 흐려진다. (양수) (단위px)
      Spread 그림자를 더 크게 확장시킨다. (음수, 양수) (단위px)

    16. 그레디언트 :  2가지 이상의 색상을 혼합하여 부드러운 색감의 배경 등을 생성하는 것 -> 그레이디언트를 직접 작성하는 것보다 작성 툴을 이용하는 것이 보편적임 
      - 선형 그레이디언트 (Linear Gradient: goes down/up/left/right/diagonally)
      - 방사형 그레이디언트 (Radial Gradient: defined by their center)

    17. 트랜지션 : CSS 프로퍼티의 값이 변화할 때 프로퍼티 값의 변화가 일정 시간 duration에 걸쳐 일어나도록 하는 것
       transition: all 2s; 변화가 2초에 걸쳐 이루어짐 
       transition은 자동으로 발동되지 않음/ :hover와 같은 가상 클래스 선택자 또는 JavaScript의 부수적인 액션에 의해 발동됨 -> 자동 발동되도록 하고 싶다면  css 애니메이션을 사용 
      - transition-property : 트랜지션의 대상이 되는 CSS 프로퍼티명을 지정/ 지정하지 않는 경우 모든 프로퍼티가 트랜지션의 대상이 됨/ 복수의 프로퍼티를 지정하는 경우 쉼표(,)로 구분함 transition-property: width, background-color;
      모든 CSS 프로퍼티가 트랜지션의 대상이 될 수 없다
      - transition-duration : 랜지션에 일어나는 지속시간(duration)을 초 단위(s) 나 밀리 초 단위(ms)로 지정/ 프로퍼티값을 지정하지 않을 경우 기본값 0s이 적용 
      - transition-timing-function : 트랜지션 효과의 변화 흐름, 시간에 따른 변화 속도와 같은 일종의 변화의 리듬을 지정/ 프로퍼티값으로 미리 정해둔 5개의 키워드가 제공됨 
      - transition-delay : 프로퍼티가 변화한 시점과 트랜지션이 실제로 시작하는 사이에 대기하는 시간을 초 단위 또는 밀리 초 단위로 지정/ transition-delay로 대기 사간을 지정하여 프로퍼티의 값이 변화하여도 즉시 트랜지션이 실행되지 않고, 일정 시간 대기한 후 트랜지션이 실행되도록 함 
      - transition :모든 트랜지션 프로퍼티를 한번에 지정할 수 있는 shorthand
    
    18. 애니메이션 = CSS 스타일 + 애니메이션의 sequence를 나타내는 복수의 키프레임(@keyframes) / transition 프로퍼티는 단순히 요소의 프로퍼티 변화에 주안점이 있다면 animation 프로퍼티는 하나의 줄거리를 구성하여 줄거리 내에서 세부 움직임을 시간 흐름 단위로 제어할 수 있고 전체 줄거리의 재생과 정지 반복까지 제어할 수 있음 
      18-1) @keyframes :  애니메이션의 흐름 중의 여러 시점에서 CSS 프로퍼티값을 지정할 수 있음/ 
      18-2) animation-name : @keyframes 애니메이션 이름 지정
      18-3) animation-duration : 한 싸이클의 애니메이션에 소요되는 시간을 초 단위 또는 밀리 초 단위로 지정한다./ 반드시 지정해야함! 지정하지 않은 경우 기본값 0s로 어떠한 애니메이션도 실행되지 않음 
      18-4) animation-timing-function :	애니메이션 효과를 위한 타이밍 함수를 지정
      18-5) animation-delay :	요소가 로드된 시점과 애니메이션이 실제로 시작하는 사이에 대기하는 시간을 초 단위 또는 밀리 초 단위 로 지정
      18-6) animation-iteration-count :	애니메이션 재생 횟수를 지정/ 기본값은 1, infinite로 무한반복 가능
      18-7) animation-direction :	애니메이션이 종료된 이후 반복될 때 진행하는 방향을 지정한다. 
        - normal/ reverse/ alternate/ alternate-reverse
      18-8) animation-fill-mode	애니메이션 미실행 시(종료 나 대기) 요소의 스타일을 지정한다.
        - none/ forwards/ backwards/ both 
      18-9) animation-play-state	애니메이션 재생 상태(재생이나 중지)를 지정/ 기본값은 running 
      18-10) animation : shorthand syntax

    19. 트랜스폼 : 요소에 이동(translate), 회전(rotate), 확대축소(scale), 비틀기(skew) 효과를 부여하기 위한 함수를 제공
      cf) 트랜지션 : CSS 스타일 변경을 부드럽게 표현하기 위해 duration(지속시간)을 부여하여 속도를 조절
          애니메이션 : 하나의 줄거리(@keyframes)를 구성하여 줄거리 내에서 세부 움직임을 시간 흐름 단위로 제어하여 요소의 움직임을 표현
      19-1) 2D 트랜스폼 : 프로퍼티값으로 변환함수를 사용
      -변환함수 종류 
        translate(x,y)	요소의 위치를 X축으로 x만큼, Y축으로 y만큼 이동시킨다.
        translateX(n)	  요소의 위치를 X축으로 x만큼 이동시킨다.
        translateY(n)	  요소의 위치를 Y축으로 y만큼 이동시킨다.
        scale(x,y)	    요소의 크기를 X축으로 x배, Y축으로 y배 확대 또는 축소 시킨다.
        scaleX(n)	      요소의 크기를 X축으로 x배 확대 또는 축소 시킨다.
        scaleY(n)     	요소의 크기를 Y축으로 y배 확대 또는 축소 시킨다.
        skew(x-angle,y-angle)	요소를 X축으로 x 각도만큼, Y축으로 y 각도만큼 기울인다.
        skewX(x-angle)	      요소를 X축으로 x 각도만큼 기울인다.	
        skewY(y-angle)      	요소를 Y축으로 y 각도만큼 기울인다.
        rotate(angle)       	요소를 angle만큼 회전시킨다.

        - transform : 변환함수를 프로퍼티값으로 쉼표없이 나열/ 나열순서에 따라 차례대로 효과가 적용
        - transform-origin : 요소의 기본기준점을 설정할 때 사용/ 기본기준점은 요소의 정중앙이다(50%,50%)
      
      19-2) 3D 트랜스폼 

    20. 웹디자인 타이포그래피 : 웹폰트는 사용자가 웹페이지를 요청한 순간 CSS에 기술된 필요 폰트가 서버에서 클라이언트로 전송된다. -> 클라이언트에 해당 폰트가 존재하지 않을 경우 전송됨 
      20-1) CDN(Content Delivery Network) 링크 방식 :  CDN 링크/ 구글 웹폰트 / 로딩 속도가 느린 단점 (로컬 폰트를 사용하는 것에 비해 느리지만 서버 폰트 로딩 방식보다는 빠를수 있음) 
      20-2) 서버 폰트 로딩 방식 : @font-face 규칙으로 폰트를 등록하고 font-family 프로퍼티로 폰트를 선택하여 사용할 수 있음/ 폰트 파일을 서버에 두고 요청이 오면 클라이언트로 전송하는 방식 / 영문과 한글을 혼용하는 경우 먼저 영문 폰트, 그 다음 한글 폰트를 지정해야함 
    
    21. 레이아웃 : layout의 핵심은 블록 레벨 요소들을 원하는 위치에 배열하는 것/ 화면의 크기에 따라 적절히 화면 구성을 변화시키는 반응형 웹 디자인 또한 모던 웹 사이트의 필수 사항
    자주 사용되는 핵심 기술은 float!!!! 
      21-1) Header & Navigation Bar
        - Navigation Bar : ul, li tag를 이용하여 작성하는 것이 일반적 
      21-2) Section & Aside : 콘텐츠의 영역을 Section, 콘텐츠에 대한 Navigation item이나 부가 정보 영역을 Aside/ Section 영역은 다시 article 영역으로 구분가능-> 일반적으로 이 두개의 영역은 float 프로퍼티를 사용하여 수평 정렬함
      header 요소 뒤에 aside, section, article을 포함하는 content-wrap 요소를 정의한다 
      21-3) footer : content-wrap 영역 다음에 footer를 배치
      fixed 프로퍼티는 스크롤이 되어도 언제나 그자리를 고수하기 때문에 본문을 가리게 될 수 있다. ->  absolute 프로퍼티를 설정/ absolute를 사용하면 다른 요소가 먼저 위치를 점유하고 있어도 뒤로 밀리지 않고 덮어쓰게 됨

    22. 반응형 레이아웃 : 화면 해상도에 따라 가로폭이나 배치를 변경하여 가독성을 높이는 것/ 하나의 웹사이트를 구축해 다양한 디바이스의 화면 해상도에 최적화된 웹사이트를 제공하는 것 
      22-1) veiwport meta tage
        - viewport란 웹페이지의 가시영역을 의미/ 디바이스마다 차이가 있음 ex) 모바일 브라우저는 주화면이 세로 화면이고 윈도우 resize가 불가하며 화면 터치를 사용하는 등 데스크탑 브라우저와 구성이나 형태가 다름
      meta tag는 브라우저 혹은 검색엔진최적화를 위해 검색엔진에게 메타데이터를 전달하기 위해 사용/ viewport meta tag는 브라우저의 화면 설정과 관련된 정보를 제공함 
      px단위 사용(단위 표현은 생략)/ 복수개의 프로퍼티를 사용할 때는 쉼표(,)로 구분
      일반적으로 모바일 디바이스에서만 적용됨 
      <meta name="viewport" content="width=device-width, initial-scale=1.0"> 가장 일반적인 viewport 설정/ 가로폭을 디바이스의 가로폭에 맞추고 초기 화면 배율을 100%로 설정하는 것을 의미
      22-2) @media : 서로 다른 미디어 타입 print, screen… 에 따라 각각의 스타일을 지정하는 것을 가능하게 함./ 
        Media Query : @media을 사용하여 미디어 별로 스타일을 지정하는 것/ 나중에 선언된 스타일이 우선 적용 -> Non Mobile First 방식의 경우 max-width의 값이 큰 것부터 기술해야함 
        Mobile-first 방식은 해상도가 작은 순서로 Non Mobile-first 방식은 해상도가 큰 순서로 기술한다. 
      22-3) Responsive Navigation Bar - Tablet  
        데스크탑 layout에서 화면이 작아질 때 header navigation bar가 header 영역 아래로 내려오는 현상이 발생되는 것을 보안하기 위해 태블릿에서의 layout을 정의
        -> viewport width가 800px 이하가 되면 header 영역을 2단(logo와 navigation bar영역)으로 구분하기 위하여 header 영역의 높이를 현재(60px)의 2배로 넓힌다. 그리고 logo image과 navigation bar를 centering한다.
      22-4) Responsive Navigation Bar - Smartphone
        태블릿 layout에서는 header 영역을 2단으로 분리하여 navigation bar는 header 하단 영역에 배치 하지만 스마트폰의 viewport width는 가로로 나란히 정렬되어 있는 navigation bar를 모두 담기에는 너무 좁음. -> 우측 navigation icon을 클릭하면 navigation bar가 수직 정렬되어 화면에 나타나도록 navigation icon에 animation 효과를 부여한다.
      22-5) Section & Aside & Footer
        article을 2열로 배치하기 위해서 width 값을 지정해야함/ %로 width 값을 지정하여 viewport에 상대적인 너비를 갖도록 한다
        + margin도 %로 지정 + float: left;를 지정하여 2열로 정렬되도록 한다.
      
    23. 플렉스 박스 레이아웃 
      23-1) Flexbox는 모던 웹을 위하여 제안된 기존 레이아웃보다 더 세련된 방식의 니즈에 부합하기 위한 CSS3의 새로운 레이아웃 방식
        - 장점 : 1줄의 코드 추가로 수평 정렬이 가능/ 요소의 상하좌우 정렬, 순서 변경이 간단함/ 요소간 간격 조절이 간단/ 서로 다른 height를 갖는 요소의 수평정렬 때에 간단히 상하중앙 정렬이 가능함
      23-2) Usage : Flexbox 레이아웃은 flex item이라 불리는 복수의 자식 요소와 이들을 내포하는 flex-container 부모 요소로 구성된다. / flexbox를 사용하기 위해서 HTML 부모 요소의 display 속성에 flex를 지정해야한다
        부모 요소가 inline 요소인 경우 inline-flex을 지정한다.
      23-3) Flexbox container 속성
        - flex-direction : flex 컨테이너의 주축 방향을 설정 
            flex-direction: row; 좌에서 우로(ltr) 수평 배치 (기본값)
            flex-direction: row-reverse; 우에서 좌로(rtl) 수평 배치
            flex-direction: column; 위에서 아래로 수직 배치
            flex-direction: column-reverse; 아래에서 위로 수직 배치
        - flex-wrap : flex 컨테이너의 복수 flex item을 1행으로 또는 복수행으로 배치함 
            flex-wrap: nowrap; flex item을 개행하지 않고 1행에 배치 (기본값)
            flex-wrap: wrap; flex item들의 width의 합계가 flex 컨테이너의 width보다 큰 경우 flex item을 복수행에 배치한다/ 기본적으로 좌에서 우, 위에서 아래로 배치됨
            flex-wrap: wrap-reverse; 아래에서 위
        - flex-flow : shorthand/ 기본값은 row nowrap
        - justify-content : main axis를 기준으로 flex item을 수평 정렬
            justify-content: flex-start; main start(좌측)를 기준으로 정렬 (기본값)
            justify-content: flex-end; main end(우측)를 기준으로 정렬
            justify-content: center; flex container의 중앙에 정렬
            justify-content: space-between; 첫번째와 마지막 flex item은 좌우 측면에 정렬되고 나머지와 균등한 간격으로 정렬
            justify-content: space-around; 균등한 간격
        - align-items : flex container의 수직 방향(cross axis)으로 정렬
            align-items: stretch; flex container의 높이(cross start에서 cross end까지의 높이)에 꽉찬 높이를 갖는다. (기본값)
            align-items: flex-start; cross start 기준으로 정렬
            align-items: flex-end; cross end 기준
            align-items: center; cross axis의 중앙
            align-items: baseline; baseline을 기준으로 정렬

      24. 수평/ 수직 중앙 정렬
        24-1) 수평정렬 
          - inline/inline-block 요소 : 정렬 대상 요소의 부모 요소에 text-align: center;를 지정
          - block 요소 : 너비를 명시적으로 지정하고 margin-right와 margin-left 프로퍼티에 auto를 지정
          - 복수의 block 요소 : 기본적으로 수직정렬됨/ 이것을 수평정렬하기 위해서는 정렬 대상 block 요소를 inline-block 요소로 변경한 후 부모 요소에 text-align: center;를 지정
          - Flexbox
        24-2) 수직 정렬
          - inline/inline-block 요소
            - Single line : 정렬 대상의 부모 요소에 padding-top과 padding-bottom 프로퍼티값을 동일하게 적용
            - Multiple lines 
            - Flexbox : vertical-align 프로퍼티를 사용하는 방법은 table 프로퍼티를 사용해야해서 번거로움/ 좀 더 간단한 방법은 flexbox를 사용하는 것
          - block 요소
            - 요소의 높이가 고정되어 있는 경우 : 부모 요소를 기준으로 절대 위치를 지정
            - 요소의 높이가 불확정 상태의 경우 : 부모 요소를 기준으로 절대 위치를 지정
            - Flexbox : 부모 요소에 Flexbox layout을 지정
        24-3) 수평/수직 정렬 : 요소의 너비와 높이가 고정되어 있는 경우, 요소의 너비와 높이가 불확정 상태의 경우 모두 사용 가능한 방법

      25. image요소 아래에 패딩된 여분의 공간 제거하기 
        컨테이너 요소로 img 요소를 래핑하면 img 요소 아래에 의도하지 않은 여분의 공간이 패딩됨. -> image 요소는 inline 요소로 image 요소는 텍스트로 취급된다. = 타이포그래피를 따른다 
        해결방법1) image 요소를 블록 요소로 전환하면 더 이상 텍스트로 취급되지 않는다. -> image 요소를 블록 요소로 전환할 수 없는 레이아웃에서는 사용할 수 없음
        해결방법2) inline 요소에 사용할 수 있는 vertical-align 프로퍼티를 사용하는 방법/ vertical-align 프로퍼티의 기본값은 baseline인데 이를 변경하여 이미지 표시 위치를 조정하는 것 -->



<!DOCTYPE html>
<html>

<head>
  <style>
    /* 구글웹폰트cdn */
    @import url(http://fonts.googleapis.com/earlyaccess/nanumgothic.css);

    * {
      font-family: 'Nanum Gothic', sans-serif;
    }

    /* 서버폰트 로딩 방식 */
    @font-face {
      font-family: myFontName;
      src: url("myFont.woff");
    }

    * {
      font-family: myFontName, sans-serif;
    }


    /* a 요소 중에 href 어트리뷰트를 갖는 모든 요소 */
    a[href] {
      color: gray;
    }

    /* a 요소 중에 target 어트리뷰트의 값이 "_blank"인 모든 요소 */
    a[target="_blank"] {
      color: red;
    }

    /* h1 요소 중에 title 어트리뷰트 값에 "first" 를 단어로 포함하는 요소 */
    h1[title~="first"] {
      color: cadetblue;
    }

    /* p 요소 중에 lang 어트리뷰트 값이 "en"과 일치하거나 "en-"로 시작하는 요소 */
    p[lang|="en"] {
      color: red;
    }

    /* a 요소 중에 href 어트리뷰트 값이 "https://"로 시작하는 요소 */
    a[href^="https://"] {
      color: darkkhaki;
    }

    /* a 요소 중에 href 어트리뷰트 값이 ".html"로 끝나는 요소 */
    a[href$=".html"] {
      color: deeppink;
    }

    /* div 요소 중에서 class 어트리뷰트 값에 "test"를 포함하는 요소 */
    div[class*="test"] {
      color: red;
    }

    /* div 요소 중에서 class 어트리뷰트 값에 "test"를 단어로 포함하는 요소 */
    div[class~="test"] {
      background-color: yellow;
    }

    /* div 요소의 후손요소 중 p 요소 */
    div p {
      color: blueviolet;
    }

    /* div 요소의 자식요소 중 p 요소 */
    div>p {
      color: blue;
    }

    /* p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택*/
    p+ul {
      color: forestgreen;
    }

    /* p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택*/
    p~ul {
      color: red;
    }

    /* a 요소가 hover 상태일 때 */
    a:hover {
      color: indigo;
    }

    /* input 요소가 focus 상태일 때 */
    input:focus {
      background-color: yellow;
    }

    /* a 요소가 방문하지 않은 링크일 때 */
    a:link {
      color: orange;
    }

    /* a 요소가 방문한 링크일 때 */
    a:visited {
      color: green;
    }

    /* a 요소에 마우스가 올라와 있을 때 */
    a:hover {
      font-weight: bold;
    }

    /* a 요소가 클릭된 상태일 때 */
    a:active {
      color: blue;
    }

    /* text input, password input 요소에 포커스가 들어와 있을 때 */
    input[type=text]:focus,
    input[type=password]:focus {
      color: red;
    }

    /* input 요소가 사용 가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 */
    input:enabled+span {
      color: blue;
    }

    /* input 요소가 사용 불가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 */
    input:disabled+span {
      color: gray;
      text-decoration: line-through;
    }

    /* input 요소가 체크 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 */
    input:checked+span {
      color: red;
    }

    /* p 요소 중에서 첫번째 자식을 선택 */
    p:first-child {
      color: red;
    }

    /* p 요소 중에서 마지막 자식을 선택 
    body 요소의 두번째 p 요소는 마지막 자식 요소가 아니다.
    body 요소의 마지막 자식 요소는 div 요소이다. */
    p:last-child {
      color: blue;
    }

    /* ol 요소의 자식 요소인 li 요소 중에서 짝수번째 요소만을 선택 */
    ol>li:nth-child(2n) {
      color: orange;
    }

    /* ol 요소의 자식 요소인 li 요소 중에서 홀수번째 요소만을 선택 */
    ol>li:nth-child(2n+1) {
      color: green;
    }

    /* ol 요소의 자식 요소인 li 요소 중에서 첫번쨰 요소만을 선택 */
    ol>li:first-child {
      color: red;
    }

    /* ol 요소의 자식 요소인 li 요소 중에서 마지막 요소만을 선택 */
    ol>li:last-child {
      color: blue;
    }

    /* ol 요소의 자식 요소인 li 요소 중에서 4번째 요소 요소만을 선택 */
    ol>li:nth-child(4) {
      background: brown;
    }

    /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 홀수번째 요소만을 선택 */
    ul> :nth-last-child(2n+1) {
      color: red;
    }

    /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 짝수번째 요소만을 선택 */
    ul> :nth-last-child(2n) {
      color: blue;
    }

    /* p 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 p 요소 */
    p:first-of-type {
      color: red;
    }

    /* p 요소의 부모 요소의 자식 요소 중 마지막 등장하는 p 요소 */
    p:last-of-type {
      color: blue;
    }

    /* p 요소의 부모 요소의 자식 요소 중 앞에서 2번째에 등장하는 p 요소 */
    p:nth-of-type(2) {
      color: green;
    }

    /* p 요소의 부모 요소의 자식 요소 중 뒤에서 2번째에 등장하는 p 요소 */
    p:nth-last-of-type(2) {
      color: orange;
    }

    /* p 요소 중에서 첫번째 자식을 선택 */
    p:first-child {
      background: brown;
    }

    /* input 요소 중에서 type 어트리뷰트의 값이 password가 아닌 요소를 선택 */
    input:not([type=password]) {
      background: olivedrab;
    }

    /* 주어진 조건을 충족시키면 greenyellow 색상 */
    input[type="text"]:valid {
      background-color: greenyellow;
    }

    /* 주어진 조건을 충족시키지 못할 경우에는 red 색상 */
    input[type="text"]:invalid {
      background-color: red;
    }

    /*p 요소 콘텐츠의 첫글자를 선택
    p::first-letter {
      font-size: 3em;
    }

    p 요소 콘텐츠의 첫줄을 선택
    p::first-line {
      color: red;
    }

    h1 요소 콘텐츠의 앞 공간에 content 어트리뷰트 값을 삽입한다
    h1::before {
      content: " HTML!!! ";
      color: blue;
    }

    h1 요소 콘텐츠의 뒷 공간에 content 어트리뷰트 값을 삽입한다 
    h1::after {
      content: " CSS3!!!";
      color: red;
    }

     드래그한 콘텐츠를 선택한다 
    ::selection {
      color: red;
      background: yellow;
    } */

    /* h1 {
      color: red;
    }

    p {
      background: aqua;
    }

    * {
      color: green;
    }

    #p1 {
      color: darkgoldenrod;
    }

    .text-center {
      text-align: center;
    }

    .text-large {
      font-size: 200%;
    }

    .text-red {
      color: red;
    }

    .text-blue {
      color: blue;
    } */

    /* body {
      text-align: center;
    } */

    /* div {
      font-size: 14px;
      font-weight: bold;
      padding: 2em;
       14px * 2 = 28px 
      background-color: rgba(255, 0, 0, 0.2);
    } */

    html {
      font-size: 14px;
      /* font-size 미지정 시에는 16px */
    }

    /* div {
      font-size: 1.2rem;
       html font-size: 14px * 1.2 = 16.8px 
      font-weight: bold;
      padding: 2em;
      text-align: center;
    } */

    .box1 {
      background-color: rgba(255, 0, 0, 0.2);
    }

    .box2 {
      background-color: rgba(255, 0, 0, 0.6);
    }

    .box3 {
      background-color: rgba(255, 0, 0, 0.8);
    }

    /* div {
      border: 5px solid red;

      margin-top: 40px;
      margin-right: 30px;
      margin-bottom: 20px;
      margin-left: 10px;

      padding-top: 10px;
      padding-right: 20px;
      padding-bottom: 30px;
      padding-left: 40px;
    } */

    /* p {
      background: palegreen;
      padding: 10px;
    } */

    p.dotted {
      border-style: dotted;
    }

    p.dashed {
      border-style: dashed;
    }

    p.solid {
      border-style: solid;
    }

    p.double {
      border-style: double;
    }

    p.groove {
      border-style: groove;
    }

    p.ridge {
      border-style: ridge;
    }

    p.inset {
      border-style: inset;
    }

    p.outset {
      border-style: outset;
    }

    p.none {
      border-style: none;
    }

    p.hidden {
      border-style: hidden;
    }

    p.mix {
      border-style: dotted dashed solid double;
    }

    p.d1 {
      /* four sides */
      border-style: dashed;
    }

    p.d2 {
      /* horizontal | vertical */
      border-style: dotted solid;
    }

    p.d3 {
      /* top | horizontal | bottom */
      border-style: hidden double dashed;
    }

    p.d4 {
      /* top | right | bottom | left */
      border-style: none solid dotted dashed;
    }

    .border-rounded {
      /* 4 꼭지점에 대해 Radius 지정 -> 모서리가 둥근 정사각형 모형 */
      border-radius: 5px;
    }

    .border-circle {
      /*-> 원형 */
      border-radius: 50%;
    }

    .border-football {
      /* top-left & bottom-right | top-right & bottom-left -> 럭비공모형 */
      border-radius: 15px 75px;
    }

    .border-rounded {
      border-radius: 20px;

      /* 아래처럼 긴 내용을 위 코드처럼 shorthand 로 표현 가능 
      모든 모서리를 동일하게 설정!
  border-top-left-radius:     20px;
  border-top-right-radius:    20px;
  border-bottom-right-radius: 20px;
  border-bottom-left-radius:  20px;
  */
    }

    .border-rounded {
      border-radius: 10px 40px 40px 10px;

      /* 각각의 모서리를 개별적으로 설정 
  border-top-left-radius:     10px;
  border-top-right-radius:    40px;
  border-bottom-right-radius: 40px;
  border-bottom-left-radius:  10px;
  */
    }

    /*두개의 반지름을 지정하여 타원형 둥근 모서리 설정 x(타원의 가로 반지름)가 50, y(타원의 세로 반지름 높이) 가 25*/
    .border-rounded {
      border-top-left-radius: 50px 25px;
    }

    /*각각의 모서리에 타원형 둥근 모서리 축약 설정 
    border-top-left-radius: 10px 5px;
    border-top-right-radius: 20px 10px;
    border-bottom-right-radius: 30px 15px;
    border-bottom-left-radius: 40px 20px;
    */
    .border-rounded {
      border-radius: 10px 20px 30px 40px / 5px 10px 15px 20px;
    }

    .visible {
      visibility: visible;
    }

    .hidden {
      visibility: hidden;
    }

    table,
    td {
      border: 1px solid black;
    }

    .collapse {
      visibility: collapse;
    }

    /* .collapse { visibility: hidden; } */

    body {
      background-image: url("http://poiemaweb.com/img/bg/dot.png"), url("http://poiemaweb.com/img/bg/paper.gif");
      background-repeat: no-repeat, repeat;
    }

    .bg {
      background-size: cover;
    }

    .font-size-40 {
      font-size: 40px;
    }

    .font-size-2x {
      font-size: 2.0em;
    }

    .font-size-150ps {
      font-size: 150%;
    }

    .font-size-large {
      font-size: large;
    }

    .serif {
      font-family: "Times New Roman", Times, serif;
    }

    .sans-serif {
      font-family: Arial, Helvetica, sans-serif;
    }

    .monospace {
      font-family: "Courier New", Courier, monospace;
    }

    .small {
      line-height: 70%;
      /* 16px * 70% */
    }

    .big {
      line-height: 1.2;
      /* 16px * 1.2 */
    }

    .lh-3x {
      line-height: 3.0;
      /* 16px * 3 */
    }

    .relative-box {
      position: relative;
      top: 50px;
      left: 50px;
    }

    body {
      margin: 0;
    }

    .fixed-box {
      position: fixed;
      color: #e55c3c;
      font-weight: bold;
      text-align: center;
      background: #2E303D;
    }

    .sidebar {
      width: 50px;
      height: 100%;
      top: 0;
      right: 0;
      padding-top: 100px;
    }

    .footer {
      width: 200px;
      width: 100%;
      height: 50px;
      bottom: 0;
      left: 0;
      line-height: 50px;
    }

    .normal-box {
      width: 100px;
      height: 100px;
    }

    .absolute-box {
      width: 100px;
      height: 100px;
      position: absolute;
    }

    /* z-index는 positon 프로퍼티가 static 이외인 요소에만 적용된다. */
    .orange {
      background-color: orange;
      z-index: 1000;
    }

    .red {
      background-color: red;
      left: 50px;
      top: 50px;
      z-index: 100;
    }

    .green {
      background-color: green;
      left: 100px;
      top: 100px;
      z-index: 10;
    }

    .blue {
      background-color: blue;
      left: 150px;
      top: 150px;
      z-index: 1;
    }

    img {
      float: left;
      margin-right: 10px;
    }

    .container {
      color: white;
      text-align: center;
      padding: 10px;
      background-color: #def0c2;
      /* 폰트 사이즈를 0으로 지정하여 두 요소 사이에 정의하지 않은 공백을 제거 */
      font-size: 0;
    }

    .d1,
    .d2 {
      display: inline-block;
      width: 50%;
      padding: 20px 0;
      /* 폰트 사이즈를 재지정 */
      font-size: 1rem;
    }

    .d1 {
      background-color: #59b1f6;
    }

    .d2 {
      background-color: #ffb5b4;
    }

    /* div {
      width: 100px;
      height: 100px;
      background: red;
    }

    div:hover {
      border-radius: 50%;
      background: blue;
    } */

    /* div 요소는 기본 상태에서 hover 상태로 변화할 때, CSS 프로퍼티 border-radius와 background 프로퍼티의 값이 변화 */

    /* div {
      width: 100px;
      height: 50px;
      background-color: red;
      margin-bottom: 10px;
      transition-property: width, background-color;
      transition-duration: 2s, 2s;
    }
    div:hover {
      width: 300px;
      background-color: blue;
    } */

    div {
      width: 100px;
      height: 50px;
      padding: 10px;
      color: white;
      background-color: red;
      margin-bottom: 10px;
      transition-property: width, opacity;
    }

    div:nth-child(1) {
      transition-duration: 0.5s;
    }

    div:nth-child(2) {
      transition-duration: 2s, 1s;
    }

    div:nth-child(3) {
      transition-duration: 5s, 2.5s;
    }

    div:hover {
      width: 300px;
      opacity: .1;
    }

    @keyframes move {

      /*@keyframes 뒤에 애니메이션을 대표하는 임의의 이름을 부여 */
      /* 애니메이션 시작 시점 */
      from {
        left: 0;
      }

      /* 애니메이션 종료 시점 */
      to {
        left: 300px;
      }

      /*->  정지 상태에서 오른쪽으로 300px 이동하는 애니메이션이 실행 */
    }

    @keyframes move {
      0% {
        left: 0;
      }

      50% {
        left: 100px;
      }

      100% {
        left: 300px;
      }

      /*from, to 키워드 대신 %를 사용 가능*/
    }
  </style>
</head>

<body>
  <h1>Hello World</h1>
  <p>embedding style</p>

  <h1 style="color: black">Hello World</h1>
  <p style="background: white">inline style</p>

  <h1>Heading</h1>
  <div class="container">
    <p id="p1">paragraph 1</p>
    <p id="p2">paragraph 2</p>
  </div>

  <p class="text-center">Center (클래스 1개)</p>
  <p class="text-large text-red">Large Red (클래스 2개)</p>
  <p class="text-center text-large text-blue">Center Large Blue (클래스 3개) </p>

  <a href="http://www.poiemaweb.com">poiemaweb.com</a><br>
  <a href="https://www.naver.com" target="_top">naver.com</a>

  <h1 title="heading first">Heading first</h1>
  <!-- 공백으로 분리된 단어여야 함 -> -first는 지정되지 않음  -->
  <h1 title="heading-first">Heading-first</h1>
  <h1 title="heading second">Heading second</h1>
  <h1 title="heading third">Heading third</h1>

  <p lang="en">Hello!</p>
  <p lang="en-us">Hi!</p>
  <p lang="en-gb">Ello!</p>
  <p lang="us">Hi!</p>
  <p lang="no">Hei!</p>

  <a href="test.html">test.html</a><br>
  <a href="test.jsp">test.jsp</a>

  <div class="first_test">The first div element.</div>
  <div class="second">The second div element.</div>
  <div class="test">The third div element.</div>
  <p class="test">This is some text in a paragraph.</p>

  <h1>Heading</h1>
  <div>
    <p>paragraph 1 div 후손 요소 p</p>
    <p>paragraph 2 div 후손 요소 p </p>
    <span>
      <p>paragraph 3 div 후손 요소 p </p>
    </span>
  </div>
  <p>paragraph 4</p>

  <div>
    <p>paragraph 1 div 자식 요소 </p>
    <p>paragraph 2 div 자식 요소</p>
    <span>
      <p>paragraph 3 div 후손 요소 (자식요소아님)</p>
    </span>
  </div>
  <p>paragraph 4</p>

  <p>The first paragraph.</p>
  <ul>
    <li>Coffee</li>
    <li>Tea</li>
    <li>Milk</li>
  </ul>

  <h2>Another list</h2>
  <ul>
    <li>Coffee</li>
    <li>Tea</li>
    <li>Milk</li>
  </ul>

  <a href="#">Hover me</a><br><br>
  <input type="text" placeholder="focus me">
  <br>

  <label>
    <a href="#" target="_blank">This is a link</a><br>
    <input type="text" value="I'll be red when focused"><br>
    <input type="password" value="I'll be red when focused">
    <hr>

    <input type="radio" checked="checked" value="male" name="gender"> <span>Male</span><br>
    <input type="radio" value="female" name="gender"> <span>Female</span><br>
    <input type="radio" value="neuter" name="gender" disabled> <span>Neuter</span>
    <hr>

    <input type="checkbox" checked="checked" value="bicycle"> <span>I have a bicycle</span><br>
    <input type="checkbox" value="car"> <span>I have a car</span><br>
    <input type="checkbox" value="motorcycle" disabled> <span>I have a motorcycle</span>
  </label>
  <p>This paragraph is the first child of its parent (body). p요소 중 첫번째 자식 요소</p>

  <h1>Welcome to My Homepage</h1>
  <p>This paragraph is not the first child of its parent.</p>

  <div>
    <p>This paragraph is the first child of its parent (div).</p>
    <p>This paragraph is not the first child of its parent. p 요소 중 마지막 자식 요소</p>
  </div>

  <ol>
    <li>Espresso</li>
    <li>Americano</li>
    <li>Caffe Latte</li>
    <li>Caffe Mocha</li>
    <li>Caramel Latte</li>
    <li>Cappuccino</li>
  </ol>

  <ul>
    <li>Espresso</li>
    <li>Americano</li>
    <li>Caffe Latte</li>
    <li>Caffe Mocha</li>
    <li>Caramel Latte</li>
    <li>Cappuccino</li>
  </ul>

  <h1>This is a heading</h1>
  <p>The first paragraph.</p>
  <p>The second paragraph.</p>
  <p>The third paragraph.</p>
  <p>The fourth paragraph.</p>
  <div>
    <h1>This is a heading</h1>
    <p>The first paragraph.</p>
    <p>The second paragraph.</p>
    <p>The third paragraph.</p>
    <p>The fourth paragraph.</p>
  </div>
  <label>
    <input type="text" value="Text input">
    <input type="email" value="email input">
    <input type="password" value="Password input">
  </label>
  <hr>

  <label>입력값이 반드시 필요
    <input type="text" required>
  </label>
  <br>
  <label>특수문자를 포함하지 않는 4자리 문자 또는 숫자
    <input type="text" value="ab1!" pattern="[a-zA-Z0-9]{4}" required>
  </label>
  <br>
  <label>핸드폰 번호 형식
    <input type="text" value="010-1111-2222" pattern="^\d{3}-\d{3,4}-\d{4}$" required>
  </label>
  <hr>
  <h1>This is a heading</h1>
  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Explicabo illum sunt distinctio sed, tempore, repellat
    rerum et ea laborum voluptatum! Quisquam error fugiat debitis maiores officiis, tenetur ullam amet in!</p>

  <div class='box1'>
    Font size: 1.2rem ⇒ 14px * 1.2 = 16.8px
    <div class='box2'>
      Font size: 1.2rem ⇒ 14px * 1.2 = 16.8px
      <div class='box3'>
        Font size: 1.2rem ⇒ 14px * 1.2 = 16.8px
      </div>
    </div>
  </div>

  <h2>border-style Property</h2>

  <p class="dotted">dotted</p>
  <p class="dashed">dashed</p>
  <p class="solid">solid</p>
  <p class="double">double</p>
  <p class="groove">groove</p>
  <p class="ridge">ridge</p>
  <p class="inset">inset</p>
  <p class="outset">outset</p>
  <p class="none">none</p>
  <p class="hidden">hidden</p>
  <p class="mix">dotted dashed solid double</p>

  <p class="d1">border-style: dashed;</p>
  <p class="d2">border-style: dotted solid;</p>
  <p class="d3">border-style: hidden double dashed;</p>
  <p class="d4">border-style: none solid dotted dashed;</p>


  <h1 class="visible">visibility: visible</h1>
  <h1 class="hidden">visibility: hidden</h1>
  <h1 style="display:none">display:none</h1>

  <table>
    <tr>
      <td>A</td>
      <td>B</td>
    </tr>
    <tr class="collapse">
      <td>C</td>
      <td>D</td>
    </tr>
  </table>

  <p>default font size: 16px</p>
  <p class='font-size-40'>font-size: 40px</p>
  <p class='font-size-2x'>font-size: 2.0em</p>
  <p class='font-size-150ps'>font-size: 150%</p>
  <p class='font-size-large'>font-size: large</p>

  <h1>font-family</h1>
  <p class="serif">Times New Roman font.</p>
  <p class="sans-serif">Arial font.</p>
  <p class="monospace">Courier New font.</p>

  <p>
    default line-height.<br>
    default line-height.<br>
    대부분 브라우저의 default line height는 약 110% ~ 120%.<br>
  </p>

  <p class="small">
    line-height: 70%<br>
    line-height: 70%<br>
  </p>

  <p class="big">
    line-height: 1.2<br>
    line-height: 1.2<br>
  </p>

  <p class="lh-3x">
    line-height: 3.0<br>
    line-height: 3.0<br>
  </p>
  <!-- 
  <div class="fixed-box sidebar">fixed box (side-bar)</div>
  <div class="fixed-box footer">fixed box (footer)</div> -->

  <div class="normal-box orange"></div>
  <div class="absolute-box red"></div>
  <div class="absolute-box green"></div>
  <div class="absolute-box blue"></div>
  <img src="https://poiemaweb.com/img/doug.jpg" alt="img">
  <div>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore
    magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
    consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
    Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.Lorem
    ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna
    aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
    Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div>

  <div class="container">
    <div class="d1">1</div>
    <div class="d2">2</div>
  </div>
  <div style="background:red;padding:10px;color:white;">3</div>

  <div>0.5s</div>
  <div>2s, 1s</div>
  <div>5s, 2.5s</div>

</body>

</html>